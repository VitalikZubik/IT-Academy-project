/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stateDOM\": () => (/* binding */ stateDOM),\n/* harmony export */   \"stateGame\": () => (/* binding */ stateGame),\n/* harmony export */   \"human\": () => (/* binding */ human),\n/* harmony export */   \"computer\": () => (/* binding */ computer)\n/* harmony export */ });\n/* harmony import */ var _src_js_field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/js/field */ \"./src/js/field.js\");\n/* harmony import */ var _src_js_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/js/dom */ \"./src/js/dom.js\");\n/* harmony import */ var _src_js_routing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/js/routing */ \"./src/js/routing.js\");\n/* harmony import */ var _src_js_placement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/js/placement */ \"./src/js/placement.js\");\n/* harmony import */ var _src_js_battle_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/js/battle-controller */ \"./src/js/battle-controller.js\");\n/* harmony import */ var _src_js_audio__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/js/audio */ \"./src/js/audio.js\");\n/* harmony import */ var _src_js_authorization__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/js/authorization */ \"./src/js/authorization.js\");\n\r\n;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst stateDOM = new _src_js_dom__WEBPACK_IMPORTED_MODULE_1__.DOM(document.querySelector('.container'));\r\nstateDOM.init();\r\n\r\nconst stateGame = {\r\n    isHandlerPlacement: false,\r\n    isHandlerController: false,\r\n    startGame: false,\r\n    compShot: false,\r\n    control: null,\r\n    isWelcome: false,\r\n    isLogin: false,\r\n    shotTime: 25,\r\n    timer: null,\r\n    title: stateDOM.getDOMState().header.querySelector('h1')\r\n}\r\n\r\nconst human = new _src_js_field__WEBPACK_IMPORTED_MODULE_0__.Field(stateDOM.getDOMState().fieldShipsHuman);\r\nlet computer = {};\r\nhuman.setStaticConstant();\r\n\r\nconst shipsCollection = stateDOM.getDOMState().shipsCollection;\r\n\r\nstateDOM.getDOMState().typePlacement.addEventListener('click', function(e) {\r\n    // используем делегирование основанное на всплытии событий\r\n    if (e.target.tagName != 'SPAN') return;\r\n\r\n    // если мы уже создали эскадру ранее, то видна кнопка начала игры\r\n    // скроем её на время повторной расстановки кораблей\r\n    document.querySelector('.btn_start_fight').classList.add('hide');\r\n    // очищаем игровое поле игрока перед повторной расстановкой кораблей\r\n    human.cleanField();\r\n\r\n    // способ расстановки кораблей на игровом поле\r\n    const type = e.target.dataset.target;\r\n    // создаём литеральный объект typeGeneration\r\n    // каждому свойству литерального объекта соответствует функция\r\n    // в которой вызывается рандомная или ручная расстановка кораблей\r\n    const typeGeneration = {\r\n        random() {\r\n            // вызов ф-ии рандомно расставляющей корабли для экземпляра игрока\r\n            human.randomLocationShips();\r\n        },\r\n        manually() {\r\n            \r\n        }\r\n    };\r\n    // вызов функции литерального объекта в зависимости\r\n    // от способа расстановки кораблей\r\n    typeGeneration[type]();\r\n\r\n    // создаём экземпляр класса, отвечающего за перетаскивание\r\n    // и редактирование положения кораблей\r\n    const placement = new _src_js_placement__WEBPACK_IMPORTED_MODULE_3__.Placement(stateDOM.getDOMState().fieldShipsHuman);\r\n    // устанавливаем обработчики событий\r\n    placement.setObserver();\r\n});\r\n\r\nstateDOM.getDOMState().btnStartFight.addEventListener('click', () => {\r\n    // скрываем не нужные для игры элементы\r\n    stateDOM.getDOMState().btnStartFight.hidden = true;\r\n\r\n    // показываем игровое поле компьютера\r\n    stateDOM.getDOMState().fieldShipsComputer.parentElement.hidden = false;\r\n\r\n    // создаём экземпляр игрового поля компьютера\r\n    computer = new _src_js_field__WEBPACK_IMPORTED_MODULE_0__.Field(stateDOM.getDOMState().fieldShipsComputer);\r\n\r\n    // очищаем поле от ранее установленных кораблей\r\n    computer.cleanField();\r\n    computer.randomLocationShips();\r\n\r\n    // устанавливаем флаг запуска игры\r\n    stateGame.startGame = true;\r\n\r\n    // создаём экземпляр контроллера, управляющего игрой\r\n    if (!stateGame.control) stateGame.control = new _src_js_battle_controller__WEBPACK_IMPORTED_MODULE_4__.BattleController();\r\n    // запускаем игру\r\n    stateGame.control.init();\r\n});\r\n\r\nstateDOM.getDOMState().btnStartOver.addEventListener('click', function(e) {\r\n    // скрываем кнопку перезапуска игры\r\n    stateDOM.getDOMState().btnStartOver.classList.add('hide');\r\n    // скрываем игровое поле компьютера\r\n    stateDOM.getDOMState().fieldShipsComputer.parentElement.hidden = true;\r\n\r\n    // очищаем поле игрока\r\n    human.cleanField();\r\n    _src_js_battle_controller__WEBPACK_IMPORTED_MODULE_4__.BattleController.SERVICE_TEXT.innerHTML = '';\r\n\r\n    // устанавливаем флаги в исходное состояние\r\n    stateGame.startGame = false;\r\n    stateGame.compShot = false;\r\n\r\n    // обнуляем массивы с координатами выстрела\r\n    stateGame.control.coordsRandomHit = [];\r\n    stateGame.control.coordsFixedHit = [];\r\n    stateGame.control.coordsAroundHit = [];\r\n    // сбрасываем значения объекта tempShip\r\n    stateGame.control.resetTempShip();\r\n});\r\n\r\n_src_js_audio__WEBPACK_IMPORTED_MODULE_5__.iconSound.addEventListener('click', _src_js_audio__WEBPACK_IMPORTED_MODULE_5__.turnOffOrOnSound);\r\n\r\nconst onWindowWelcome = () => {\r\n    document.querySelector('.window_welcome').classList.add('hide');\r\n    document.querySelector('.main_menu').classList.remove('hide');\r\n    document.querySelector('.menu').classList.add('hide');\r\n    document.querySelectorAll('.wrap_field').forEach(elem=>elem.classList.add('hide'))\r\n    document.querySelector('.placement_instruction').classList.add('hide');\r\n    document.querySelector('.btn_start_fight').classList.add('hide');\r\n    document.querySelector('.btn_exit').classList.add('hide');\r\n    document.querySelector('.btn_entry').classList.add('hide');\r\n    document.querySelector('.btn_continue').classList.add('hide');\r\n    document.querySelector('.icon_sound').classList.remove('hide');\r\n    stateGame.title.innerHTML = 'Морской бой';\r\n\r\n    if (stateGame.isLogin) {\r\n        stateDOM.getDOMState().btnExit.classList.remove('hide');\r\n        stateDOM.getDOMState().btnEntry.classList.add('hide');\r\n        stateDOM.getDOMState().btnPlay.classList.remove('hide');\r\n    } else {\r\n        stateDOM.getDOMState().btnExit.classList.add('hide');\r\n        stateDOM.getDOMState().btnEntry.classList.remove('hide');\r\n        stateDOM.getDOMState().btnPlay.classList.add('hide');\r\n    }\r\n\r\n    stateDOM.getDOMState().windowWelcome.removeEventListener('click', onWindowWelcome);\r\n\r\n    (0,_src_js_audio__WEBPACK_IMPORTED_MODULE_5__.turnOnSound) ();\r\n    stateGame.isWelcome = true;\r\n}\r\n\r\nstateDOM.getDOMState().windowWelcome.addEventListener('click', onWindowWelcome);\r\nstateDOM.getDOMState().btnEntryLogin.addEventListener('click', _src_js_authorization__WEBPACK_IMPORTED_MODULE_6__.authorization.onClickBtnEntry);\r\nstateDOM.getDOMState().btnRegistration.addEventListener('click', _src_js_authorization__WEBPACK_IMPORTED_MODULE_6__.authorization.onClickBtnRegistration);\r\n\r\nconst routing = new _src_js_routing__WEBPACK_IMPORTED_MODULE_2__.Routing(stateDOM.getDOMState());\r\nrouting.switchToStateFromURLHash();\r\nrouting.setObserver();\r\n\r\nstateDOM.getDOMState().form.addEventListener('submit', async (e) => {\r\n    e.preventDefault();\r\n\r\n    const form = stateDOM.getDOMState().form;\r\n    \r\n    let data = {};\r\n\r\n    let result;\r\n\r\n    for (let elem of form) {\r\n        if (elem.tagName === 'INPUT') {\r\n            data[elem.id] = elem.value;\r\n        }\r\n\r\n        if (elem.tagName === 'BUTTON') {\r\n            if (elem.innerHTML === 'Войти') {\r\n                result = await _src_js_authorization__WEBPACK_IMPORTED_MODULE_6__.authorization.login(data);\r\n            } else {\r\n                result = await _src_js_authorization__WEBPACK_IMPORTED_MODULE_6__.authorization.registration(data);\r\n            }\r\n        }\r\n    }\r\n    if (result.name) {\r\n        stateGame.isLogin = true;\r\n        routing.switchToMainPage();\r\n        \r\n        for (let elem of stateDOM.getDOMState().form) {\r\n            if (elem.tagName === 'INPUT') {\r\n                elem.value = '';\r\n            }\r\n        }\r\n    } else if (result.message === 'Пользователь успешно создан!') {\r\n        stateDOM.getDOMState().header.querySelector('p').innerHTML = result.message;\r\n        setTimeout(() => {stateDOM.getDOMState().header.querySelector('p').innerHTML = '';}, 1000)\r\n        _src_js_authorization__WEBPACK_IMPORTED_MODULE_6__.authorization.onClickBtnEntry();\r\n\r\n        for (let elem of stateDOM.getDOMState().form) {\r\n            if (elem.tagName === 'INPUT') {\r\n                elem.value = '';\r\n            }\r\n        }\r\n    } else {\r\n        stateDOM.getDOMState().header.querySelector('p').innerHTML = result.message;\r\n        setTimeout(() => {stateDOM.getDOMState().header.querySelector('p').innerHTML = '';}, 2000)\r\n    }\r\n\r\n});\r\n\r\n\n\n//# sourceURL=webpack://project/./index.js?");

/***/ }),

/***/ "./src/js/audio.js":
/*!*************************!*\
  !*** ./src/js/audio.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"iconSound\": () => (/* binding */ iconSound),\n/* harmony export */   \"turnOnSound\": () => (/* binding */ turnOnSound),\n/* harmony export */   \"turnOffOrOnSound\": () => (/* binding */ turnOffOrOnSound),\n/* harmony export */   \"turnOnSplash\": () => (/* binding */ turnOnSplash),\n/* harmony export */   \"turnOnExplosion\": () => (/* binding */ turnOnExplosion)\n/* harmony export */ });\n\r\n\r\nconst iconSound = document.querySelector('.icon_sound');\r\nconst volumeMain = document.querySelector('.volume');\r\nconst stateOfSounds = {};\r\n\r\nstateOfSounds.volumeMain = volumeMain.value;\r\n\r\nstateOfSounds.main = new Audio('./src/audio/main.mp3');\r\nstateOfSounds.main.loop = true;\r\n\r\nstateOfSounds.splash = new Audio('./src/audio/splash.mp3');\r\nstateOfSounds.explosion = new Audio('./src/audio/explosion.mp3');\r\n\r\nconst setVolumeMain = (e) => {\r\n    stateOfSounds.volumeMain = e.target.value;\r\n    stateOfSounds.main.volume = stateOfSounds.volumeMain;\r\n    if(stateOfSounds.volumeMain === '0') {\r\n        iconSound.style.backgroundImage = 'url(./src/img/off.png)';\r\n        iconSound.classList.add('off'); \r\n    } else {\r\n        iconSound.style.backgroundImage = 'url(./src/img/on.png)';\r\n        iconSound.classList.remove('off'); \r\n    }\r\n}\r\n\r\nconst turnOnSound = () => {\r\n    stateOfSounds.main.currentTime = 0; \r\n    stateOfSounds.main.play();\r\n    stateOfSounds.play = true;\r\n}\r\n\r\nconst turnOffOrOnSound = (e) => {\r\n    if (e.target.tagName === 'DIV') {\r\n        if(stateOfSounds.play) {\r\n            stateOfSounds.main.pause();\r\n            iconSound.style.backgroundImage = 'url(./src/img/off.png)';\r\n            iconSound.classList.add('off'); \r\n            stateOfSounds.play = false;\r\n            volumeMain.value = '0'\r\n        } else {\r\n            stateOfSounds.main.play();\r\n            iconSound.style.backgroundImage = 'url(./src/img/on.png)';\r\n            iconSound.classList.remove('off'); \r\n            stateOfSounds.play = true;\r\n            volumeMain.value = stateOfSounds.volumeMain\r\n        }\r\n    }\r\n}\r\n\r\nconst turnOnSplash = () => {\r\n    stateOfSounds.splash.pause();\r\n    stateOfSounds.splash.currentTime = 0;\r\n    stateOfSounds.splash.play();\r\n}\r\n\r\nconst turnOnExplosion = () => {\r\n    stateOfSounds.explosion.pause();\r\n    stateOfSounds.explosion.currentTime = 0;\r\n    stateOfSounds.explosion.play();\r\n    setTimeout(() => {\r\n        stateOfSounds.explosion.pause();\r\n    }, 1500);\r\n}\r\n\r\nvolumeMain.addEventListener('input', setVolumeMain)\n\n//# sourceURL=webpack://project/./src/js/audio.js?");

/***/ }),

/***/ "./src/js/authorization.js":
/*!*********************************!*\
  !*** ./src/js/authorization.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"authorization\": () => (/* binding */ authorization)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../.. */ \"./index.js\");\n\r\n\r\nconst authorization = {\r\n    onClickBtnEntry: () => {\r\n        ___WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().btnEntryLogin.classList.add('active_btn');\r\n        ___WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().btnRegistration.classList.remove('active_btn');\r\n        document.querySelector('.wrap_input_name').classList.add('hide');\r\n\r\n        ___WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().btnSubmit.innerHTML = 'Войти';\r\n\r\n        for (let elem of ___WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().form) {\r\n            if (elem.tagName === 'INPUT') {\r\n                elem.value = '';\r\n            }\r\n        }\r\n    },\r\n\r\n    onClickBtnRegistration: () => {\r\n        ___WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().btnEntryLogin.classList.remove('active_btn');\r\n        ___WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().btnRegistration.classList.add('active_btn');\r\n        document.querySelector('.wrap_input_name').classList.remove('hide');\r\n\r\n        ___WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().btnSubmit.innerHTML = 'Зарегистрировать';\r\n\r\n        for (let elem of ___WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().form) {\r\n            if (elem.tagName === 'INPUT') {\r\n                elem.value = '';\r\n            }\r\n        }\r\n    },\r\n\r\n    login: async (data) => {\r\n        const response = await fetch('https://mysterious-reef-68631.herokuapp.com/SeaBattle/users/login', {\r\n            method: \"POST\" ,\r\n            headers: {\r\n                'Content-Type': 'Application/json'\r\n            },\r\n            body: JSON.stringify(data)\r\n        })\r\n        const result = await response.json();\r\n        return result;\r\n    },\r\n\r\n    registration: async (data) => {\r\n        const response = await fetch('https://mysterious-reef-68631.herokuapp.com/SeaBattle/users', {\r\n            method: \"POST\" ,\r\n            headers: {\r\n                'Content-Type': 'Application/json'\r\n            },\r\n            body: JSON.stringify(data)\r\n        })\r\n        const result = await response.json();\r\n        return result;\r\n    }\r\n};\r\n\r\n\n\n//# sourceURL=webpack://project/./src/js/authorization.js?");

/***/ }),

/***/ "./src/js/battle-controller.js":
/*!*************************************!*\
  !*** ./src/js/battle-controller.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BattleController\": () => (/* binding */ BattleController)\n/* harmony export */ });\n/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./field */ \"./src/js/field.js\");\n/* harmony import */ var _ships__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ships */ \"./src/js/ships.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../index */ \"./index.js\");\n/* harmony import */ var _audio__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./audio */ \"./src/js/audio.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass BattleController {\r\n    // массив базовых координат для формирования coordsFixedHit\r\n    static START_POINTS = [\r\n        [ [6,0], [2,0], [0,2], [0,6] ],\r\n        [ [3,0], [7,0], [9,2], [9,6] ]\r\n    ];\r\n    // Блок, в который выводятся информационные сообщения по ходу игры\r\n    static SERVICE_TEXT;\r\n\r\n    constructor() {\r\n        this.player = '';\r\n        this.opponent = '';\r\n        this.text = '';\r\n        // массив с координатами выстрелов при рандомном выборе\r\n        this.coordsRandomHit = [];\r\n        // массив с заранее вычисленными координатами выстрелов\r\n        this.coordsFixedHit = [];\r\n        // массив с координатами вокруг клетки с попаданием\r\n        this.coordsAroundHit = [];\r\n        // временный объект корабля, куда будем заносить координаты\r\n        // попаданий, расположение корабля, количество попаданий\r\n        this.resetTempShip();\r\n        this.setServiceText();\r\n    }\r\n\r\n    // вывод информационных сообщений\r\n    static showServiceText = text => {\r\n        BattleController.SERVICE_TEXT.innerHTML = text;\r\n    }\r\n\r\n    // преобразование абсолютных координат иконок в координаты матрицы\r\n    static getCoordsIcon = el => {\r\n        const x = el.style.top.slice(0, -2) / _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE;\r\n        const y = el.style.left.slice(0, -2) / _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE;\r\n        return [x, y];\r\n    }\r\n\r\n    // удаление ненужных координат из массива\r\n    static removeElementArray = (arr, [x, y]) => {\r\n        return arr.filter(item => item[0] != x || item[1] != y);\r\n    }\r\n\r\n    setServiceText() {\r\n        BattleController.SERVICE_TEXT = _index__WEBPACK_IMPORTED_MODULE_2__.stateDOM.getDOMState().header.querySelector('p');\r\n    }\r\n\r\n    init() {\r\n        // Рандомно выбираем игрока и его противника\r\n        const random = _field__WEBPACK_IMPORTED_MODULE_0__.Field.getRandom(1);\r\n        this.player = (random == 0) ? _index__WEBPACK_IMPORTED_MODULE_2__.human : _index__WEBPACK_IMPORTED_MODULE_2__.computer;\r\n        this.opponent = (this.player === _index__WEBPACK_IMPORTED_MODULE_2__.human) ? _index__WEBPACK_IMPORTED_MODULE_2__.computer : _index__WEBPACK_IMPORTED_MODULE_2__.human;\r\n\r\n        // генерируем координаты выстрелов компьютера и заносим их в\r\n        // массивы coordsRandomHit и coordsFixedHit\r\n        this.setCoordsShot();\r\n\r\n        // обработчики события для игрока\r\n        if (!_index__WEBPACK_IMPORTED_MODULE_2__.stateGame.isHandlerController) {\r\n            //выстрел игрока\r\n            _index__WEBPACK_IMPORTED_MODULE_2__.stateDOM.getDOMState().fieldShipsComputer.addEventListener('click', this.makeShot.bind(this));\r\n            // устанавливаем маркер на заведомо пустую клетку\r\n            _index__WEBPACK_IMPORTED_MODULE_2__.stateDOM.getDOMState().fieldShipsComputer.addEventListener('contextmenu', this.setUselessCell.bind(this));\r\n            _index__WEBPACK_IMPORTED_MODULE_2__.stateGame.isHandlerController = true;\r\n        }\r\n\r\n        if (this.player === _index__WEBPACK_IMPORTED_MODULE_2__.human) {\r\n            _index__WEBPACK_IMPORTED_MODULE_2__.stateGame.compShot = false;\r\n            this.text = 'Вы стреляете первым';\r\n\r\n        } else {\r\n            _index__WEBPACK_IMPORTED_MODULE_2__.stateGame.compShot = true;\r\n            this.text = 'Первым стреляет компьютер';\r\n            // выстрел компьютера\r\n            setTimeout(() => this.makeShot(), 2000);\r\n        }\r\n        BattleController.showServiceText(this.text);\r\n    }\r\n\r\n    setCoordsShot() {\r\n        // получаем координаты каждой клетки игрового поля\r\n        // и записываем их в массив\r\n        for (let i = 0; i < 10; i++) {\r\n            for(let j = 0; j < 10; j++) {\r\n                this.coordsRandomHit.push([i, j]);\r\n            }\r\n        }\r\n        // рандомно перемешиваем массив с координатами\r\n        this.coordsRandomHit.sort((a, b) => Math.random() - 0.5);\r\n\r\n        let x, y;\r\n\r\n        // получаем координаты для обстрела по диагонали вправо-вниз\r\n        for (let arr of BattleController.START_POINTS[0]) {\r\n            x = arr[0]; y = arr[1];\r\n            while (x <= 9 && y <= 9) {\r\n                this.coordsFixedHit.push([x, y]);\r\n                x = (x <= 9) ? x : 9;\r\n                y = (y <= 9) ? y : 9;\r\n                x++; y++;\r\n            }\r\n        }\r\n\r\n        // получаем координаты для обстрела по диагонали вправо-вверх\r\n        for (let arr of BattleController.START_POINTS[1]) {\r\n            x = arr[0]; y = arr[1];\r\n            while(x >= 0 && x <= 9 && y <= 9) {\r\n                this.coordsFixedHit.push([x, y]);\r\n                x = (x >= 0 && x <= 9) ? x : (x < 0) ? 0 : 9;\r\n                y = (y <= 9) ? y : 9;\r\n                x--; y++;\r\n            };\r\n        }\r\n        // изменим порядок следования элементов на обратный,\r\n        // чтобы обстрел происходил в очерёдности согласно рисунка\r\n        this.coordsFixedHit = this.coordsFixedHit.reverse();\r\n    }\r\n\r\n    setCoordsAroundHit(x, y, coords) {\r\n        let {firstHit, kx, ky} = this.tempShip;\r\n\r\n        // массив пустой, значит это первое попадание в данный корабль\r\n        if (firstHit.length == 0) {\r\n            this.tempShip.firstHit = [x, y];\r\n        // второе попадание, т.к. оба коэффициента равны 0\r\n        } else if (kx == 0 && ky == 0) {\r\n            // зная координаты первого и второго попадания,\r\n            // можно вычислить направление расположение корабля\r\n            this.tempShip.kx = (Math.abs(firstHit[0] - x) == 1) ? 1 : 0;\r\n            this.tempShip.ky = (Math.abs(firstHit[1] - y) == 1) ? 1 : 0;\r\n        }\r\n\r\n        // проверяем корректность полученных координат обстрела\r\n        for (let coord of coords) {\r\n            x = coord[0]; y = coord[1];\r\n            // координаты за пределами игрового поля\r\n            if (x < 0 || x > 9 || y < 0 || y > 9) continue;\r\n            // по данным координатам установлен промах или маркер пустой клетки\r\n            if (_index__WEBPACK_IMPORTED_MODULE_2__.human.matrix[x][y] != 0 && _index__WEBPACK_IMPORTED_MODULE_2__.human.matrix[x][y] != 1) continue;\r\n            // валидные координаты добавляем в массив\r\n            this.coordsAroundHit.push([x, y]);\r\n        }\r\n    }\r\n\r\n    isShipSunk() {\r\n        // max кол-во палуб у оставшихся кораблей\r\n        let obj = Object.values(_index__WEBPACK_IMPORTED_MODULE_2__.human.squadron)\r\n            .reduce((a, b) => a.arrDecks.length > b.arrDecks.length ? a : b);\r\n        // определяем, есть ли ещё корабли, с кол-вом палуб больше, чем попаданий\r\n        if (this.tempShip.hits >= obj.arrDecks.length || this.coordsAroundHit.length == 0) {\r\n            // корабль потоплен, отмечаем useless cell вокруг него\r\n            this.markUselessCellAroundShip();\r\n            // очищаем массив coordsAroundHit и объект resetTempShip для\r\n            // обстрела следующего корабля\r\n            this.coordsAroundHit = [];\r\n            this.resetTempShip();\r\n        }\r\n    }\r\n\r\n    setUselessCell(e) {\r\n        e.preventDefault();\r\n        // проверяем нажатие правой кнопки мыши и флага, блокирующего\r\n        // действия игрока\r\n        if (e.which != 3 || _index__WEBPACK_IMPORTED_MODULE_2__.stateGame.compShot) return;\r\n\r\n        // преобразуем координаты клика относительно окна браузера, в кординаты матрицы\r\n        const coords = this.transformCoordsInMatrix(e, _index__WEBPACK_IMPORTED_MODULE_2__.computer);\r\n        // проверяем наличие иконок по полученным координатам\r\n        // если иконка присутствует, то, в зависимости от типа, удаляем её или\r\n        // кратковременно подсвечиваем красным цветом\r\n        const check = this.checkUselessCell(coords);\r\n        // если по данным координатам иконки отсутствуют, устанавливаем маркер\r\n        // пустой клетки\r\n        if (check) {\r\n            this.showIcons(this.opponent, coords, 'buoy');\r\n        }\r\n    }\r\n\r\n    checkUselessCell(coords) {\r\n        // данная строчка кода используется при установке маркера игроком\r\n        // если значение матрицы по полученным координатам отлично от нуля,\r\n        // считаем, что в этом месте уже установлена некая иконка  \r\n        if (_index__WEBPACK_IMPORTED_MODULE_2__.computer.matrix[coords[0]][coords[1]] > 1) return false;\r\n\r\n        // получаем коллекцию маркеров на игровом поле противника\r\n        const icons = this.opponent.field.querySelectorAll('.buoy');\r\n        if (icons.length == 0) return true;\r\n\r\n        for (let icon of icons) {\r\n            // получаем координаты иконки и сравниваем их с аргументом функции\r\n            const [x, y] = BattleController.getCoordsIcon(icon);\r\n            if (coords[0] == x && coords[1] == y) {\r\n                // если координаты иконки и координаты полученные в аргументе совпали,\r\n                // проверяем, какая функция вызвала функцию checkUselessCell\r\n                const f = (new Error()).stack.split('\\n')[2].trim().split(' ')[1];\r\n                if (f == 'BattleController.setUselessCell') {\r\n                    // удаляем маркер пустой клетки\r\n                    icon.remove();\r\n                } \r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // устанавливаем маркеры вокруг корабля при попадании\r\n    markUselessCell(coords) {\r\n        let n = 1, x, y;\r\n\r\n        for (let coord of coords) {\r\n            x = coord[0]; y = coord[1];\r\n            // координаты за пределами игрового поля\r\n            if (x < 0 || x > 9 || y < 0 || y > 9) continue;\r\n            // по этим координатам в матрице уже прописан промах или маркер пустой клетки\r\n            if (_index__WEBPACK_IMPORTED_MODULE_2__.human.matrix[x][y] == 2 || _index__WEBPACK_IMPORTED_MODULE_2__.human.matrix[x][y] == 3) continue;\r\n            // прописываем значение, соответствующее маркеру пустой клетки\r\n            _index__WEBPACK_IMPORTED_MODULE_2__.human.matrix[x][y] = 2;\r\n            // вывоим маркеры пустых клеток по полученным координатам\r\n            // для того, чтобы маркеры выводились поочерёдно, при каждой итерации\r\n            // увеличиваем задержку перед выводом маркера\r\n            setTimeout(() => this.showIcons(_index__WEBPACK_IMPORTED_MODULE_2__.human, coord, 'buoy'), 350 * n);\r\n            // удаляем полученные координаты из всех массивов\r\n            this.removeCoordsFromArrays(coord);\r\n            n++;\r\n        }\r\n    }\r\n\r\n    transformCoordsInMatrix(e, self) {\r\n        const x = Math.trunc((e.pageY - self.fieldTop) / _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE);\r\n        const y = Math.trunc((e.pageX - self.fieldLeft) / _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE);\r\n        return [x, y];\r\n    }\r\n\r\n    removeCoordsFromArrays(coords) {\r\n        if (this.coordsAroundHit.length > 0) {\r\n            this.coordsAroundHit = BattleController.removeElementArray(this.coordsAroundHit, coords);\r\n        }\r\n        if (this.coordsFixedHit.length > 0) {\r\n            this.coordsFixedHit = BattleController.removeElementArray(this.coordsFixedHit, coords);\r\n        }\r\n        this.coordsRandomHit = BattleController.removeElementArray(this.coordsRandomHit, coords);\r\n    }\r\n\r\n    // устанавливаем маркеры после уничтожения корабля\r\n    markUselessCellAroundShip(){\r\n        // присваиваем переменным соответствующие значения из объекта tempShip\r\n        const {hits, kx, ky, x0, y0} = this.tempShip;\r\n        let coords;\r\n\r\n        // рассчитываем координаты пустых клеток\r\n        // однопалубный корабль\r\n        if (this.tempShip.hits == 1) {\r\n            coords = [\r\n                // верхняя\r\n                [x0 - 1, y0],\r\n                // нижняя\r\n                [x0 + 1, y0],\r\n                // левая\r\n                [x0, y0 - 1],\r\n                // правая\r\n                [x0, y0 + 1]\r\n            ];\r\n        // многопалубный корабль\r\n        } else {\r\n            coords = [\r\n                // левая / верхняя\r\n                [x0 - kx, y0 - ky],\r\n                // правая / нижняя\r\n                [x0 + kx * hits, y0 + ky * hits]\r\n            ];\r\n        }\r\n        this.markUselessCell(coords);\r\n    }\r\n\r\n    showIcons(opponent, [x, y], iconClass) {\r\n        // экземпляр игрового поля на котором будет размещена иконка\r\n        const field = opponent.field;\r\n        // небольшая задержка при формировании иконок промаха и попадания\r\n        if (iconClass === 'dot' || iconClass === 'red-cross') {\r\n            setTimeout(() => fn(), 400);\r\n        } else {\r\n            fn();\r\n        }\r\n        function fn() {\r\n            // создание элемента и добавление ему класса и стилей\r\n            const span = document.createElement('span');\r\n            span.className = `icon-field ${iconClass}`;\r\n            span.style.cssText = `\r\n                left:${y * _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE}px; \r\n                top:${x * _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE}px; \r\n                width:${_field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE}px; \r\n                height:${_field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE}px; \r\n            `;\r\n\r\n            // размещаем иконку на игровом поле\r\n            field.appendChild(span);\r\n        }\r\n    }\r\n\r\n    showExplosion (x, y) {\r\n        this.showIcons(this.opponent, [x, y], 'splash');\r\n        const explosion = this.opponent.field.querySelector('.splash');\r\n        explosion.classList.add('active');\r\n        setTimeout(() => explosion.remove(), 430);\r\n    }\r\n\r\n    showAnimation (x, y, animation) {\r\n        this.showIcons(this.opponent, [x, y], `${animation}`);\r\n        const explosion = this.opponent.field.querySelector(`.${animation}`);\r\n        explosion.classList.add('active');\r\n        setTimeout(() => explosion.remove(), 430);\r\n    }\r\n\r\n    getCoordsForShot() {\r\n        const coords = (this.coordsAroundHit.length > 0) ? this.coordsAroundHit.pop() : (this.coordsFixedHit.length > 0) ? this.coordsFixedHit.pop() : this.coordsRandomHit.pop();\t\t\t\r\n        // удаляем полученные координаты из всех массивов\r\n        this.removeCoordsFromArrays(coords);\r\n        return coords;\r\n    }\r\n\r\n    resetTempShip() {\r\n        this.tempShip = {\r\n            hits: 0,\r\n            firstHit: [],\r\n            kx: 0,\r\n            ky: 0\r\n        };\r\n    }\r\n\r\n    makeShot(e) {\r\n        let x, y;\r\n        // если событие существует, значит выстрел сделан игроком\r\n        if (e !== undefined) {\r\n            // если клик не левой кнопкой мыши или установлен флаг compShot,\r\n            // что значит, должен стрелять компьютер\r\n            if (e.which != 1 || _index__WEBPACK_IMPORTED_MODULE_2__.stateGame.compShot) return;\r\n            // координаты выстрела в системе координат матрицы\r\n            ([x, y] = this.transformCoordsInMatrix(e, this.opponent));\r\n\r\n            // проверяем наличие иконки 'shaded-cell' по полученым координатам\r\n            const check = this.checkUselessCell([x, y]);\r\n            if (!check) return;\r\n        } else {\r\n            // получаем координаты для выстрела компьютера\r\n            ([x, y] = this.getCoordsForShot());\r\n        }\r\n\r\n        // показываем и удаляем иконку выстрела\r\n        // this.showExplosion(x, y);\r\n\r\n        const v\t= this.opponent.matrix[x][y];\r\n        switch(v) {\r\n            case 0: // промах\r\n                (0,_audio__WEBPACK_IMPORTED_MODULE_3__.turnOnSplash)();\r\n                this.showAnimation(x,y,'splash');\r\n                this.miss(x, y);\r\n                break;\r\n            case 1: // попадание\r\n                (0,_audio__WEBPACK_IMPORTED_MODULE_3__.turnOnExplosion)();\r\n                this.showAnimation(x,y,'explosion');\r\n                this.hit(x, y);\r\n                break;\r\n            case 3: // повторный обстрел\r\n            case 4:\r\n                BattleController.showServiceText('По этим координатам вы уже стреляли!');\r\n                break;\r\n        }\r\n    }\r\n\r\n    miss(x, y) {\r\n        let text = '';\r\n        // устанавливаем иконку промаха и записываем промах в матрицу\r\n        this.showIcons(this.opponent, [x, y], 'dot');\r\n        this.opponent.matrix[x][y] = 3;\r\n\r\n        // определяем статус игроков\r\n        if (this.player === _index__WEBPACK_IMPORTED_MODULE_2__.human) {\r\n            text = 'Вы промахнулись. Стреляет компьютер.';\r\n            this.player = _index__WEBPACK_IMPORTED_MODULE_2__.computer;\r\n            this.opponent = _index__WEBPACK_IMPORTED_MODULE_2__.human;\r\n            _index__WEBPACK_IMPORTED_MODULE_2__.stateGame.compShot = true;\r\n            setTimeout(() => this.makeShot(), 2000);\r\n        } else {\r\n            text = 'Компьютер промахнулся. Ваш выстрел.';\r\n\r\n            // обстреляны все возможные клетки для данного корабля\r\n            if (this.coordsAroundHit.length == 0 && this.tempShip.hits > 0) {\r\n                // корабль потоплен, отмечаем useless cell вокруг него\r\n                this.markUselessCellAroundShip();\r\n                this.resetTempShip();\r\n            }\r\n            this.player = _index__WEBPACK_IMPORTED_MODULE_2__.human;\r\n            this.opponent = _index__WEBPACK_IMPORTED_MODULE_2__.computer;\r\n            _index__WEBPACK_IMPORTED_MODULE_2__.stateGame.compShot = false;\r\n        }\r\n        setTimeout(() => BattleController.showServiceText(text), 400);\r\n    }\r\n\r\n    hit(x, y) {\r\n        let text = '';\r\n        // устанавливаем иконку попадания и записываем попадание в матрицу\r\n        this.showIcons(this.opponent, [x, y], 'red-cross');\r\n        this.opponent.matrix[x][y] = 4;\r\n        // выводим текст, зависящий от стреляющего\r\n        text = (this.player === _index__WEBPACK_IMPORTED_MODULE_2__.human) ? 'Поздравляем! Вы попали. Ваш выстрел.' : 'Компьютер попал в ваш корабль. Выстрел компьютера';\r\n        setTimeout(() => BattleController.showServiceText(text), 400);\r\n\r\n        // перебираем корабли эскадры противника\r\n        outerloop:\r\n        for (let name in this.opponent.squadron) {\r\n            const dataShip = this.opponent.squadron[name];\r\n            for (let value of dataShip.arrDecks) {\r\n                // перебираем координаты палуб и сравниваем с координатами попадания\r\n                // если координаты не совпадают, переходим к следующей итерации\r\n                if (value[0] != x || value[1] != y) continue;\r\n                dataShip.hits++;\r\n                if (dataShip.hits < dataShip.arrDecks.length) break outerloop;\r\n                // код для выстрела компьютера: сохраняем координаты первой палубы\r\n                if (this.opponent === _index__WEBPACK_IMPORTED_MODULE_2__.human) {\r\n                    this.tempShip.x0 = dataShip.x;\r\n                    this.tempShip.y0 = dataShip.y;\r\n                }\r\n                // если количество попаданий в корабль равно количеству палуб,\r\n                // удаляем данный корабль из массива эскадры\r\n                delete this.opponent.squadron[name];\r\n                break outerloop;\r\n            }\r\n        }\r\n\r\n        // все корабли эскадры уничтожены\r\n        if (Object.keys(this.opponent.squadron).length == 0) {\r\n            if (this.opponent === _index__WEBPACK_IMPORTED_MODULE_2__.human) {\r\n                text = 'К сожалению, вы проиграли.';\r\n                // показываем оставшиеся корабли компьютера\r\n                for (let name in _index__WEBPACK_IMPORTED_MODULE_2__.computer.squadron) {\r\n                    const dataShip = _index__WEBPACK_IMPORTED_MODULE_2__.computer.squadron[name];\r\n                    _ships__WEBPACK_IMPORTED_MODULE_1__.Ships.showShip(_index__WEBPACK_IMPORTED_MODULE_2__.computer, name, dataShip.x, dataShip.y, dataShip.kx );\r\n                }\r\n            } else {\r\n                text = 'Поздравляем! Вы выиграли!';\r\n            }\r\n            BattleController.showServiceText(text);\r\n            // показываем кнопку продолжения игры\r\n            // buttonNewGame.hidden = false;\r\n            _index__WEBPACK_IMPORTED_MODULE_2__.stateDOM.getDOMState().btnStartOver.classList.remove('hide');\r\n        // бой продолжается\r\n        } else if (this.opponent === _index__WEBPACK_IMPORTED_MODULE_2__.human) {\r\n            let coords;\r\n            this.tempShip.hits++;\r\n\r\n            // отмечаем клетки по диагонали, где точно не может стоять корабль\r\n            coords = [\r\n                [x - 1, y - 1],\r\n                [x - 1, y + 1],\r\n                [x + 1, y - 1],\r\n                [x + 1, y + 1]\r\n            ];\r\n            this.markUselessCell(coords);\r\n\r\n            // формируем координаты обстрела вокруг попадания\r\n            coords = [\r\n                [x - 1, y],\r\n                [x + 1, y],\r\n                [x, y - 1],\r\n                [x, y + 1]\r\n            ];\r\n            this.setCoordsAroundHit(x, y, coords);\r\n\r\n            // проверяем, потоплен ли корабль, в который было попадание\r\n            this.isShipSunk();\r\n\r\n            // после небольшой задержки, компьютер делает новый выстрел\r\n            setTimeout(() => this.makeShot(), 2000);\r\n        }\r\n    }\r\n}\n\n//# sourceURL=webpack://project/./src/js/battle-controller.js?");

/***/ }),

/***/ "./src/js/dom.js":
/*!***********************!*\
  !*** ./src/js/dom.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DOM\": () => (/* binding */ DOM)\n/* harmony export */ });\n\r\n\r\nclass DOM {\r\n    constructor (parent) {\r\n        this.parent = parent;\r\n        this.DOMState = {}\r\n    }\r\n\r\n    init = () => {\r\n        this.createLoginPage();\r\n        this.createWindowWelcome();\r\n        this.createHeader();\r\n        this.createMainMenu();\r\n        this.createBattleground();\r\n        this.createPlacementInstruction();\r\n    }\r\n\r\n    getDOMState = () => {\r\n        return this.DOMState;\r\n    }\r\n\r\n    createLoginPage = () => {\r\n        let value = ''\r\n        this.DOMState.wrapAuthorization = document.createElement('div');\r\n        this.DOMState.wrapAuthorization.setAttribute('class', 'wrap_authorization');\r\n\r\n        this.DOMState.btnEntryLogin = document.createElement('button');\r\n        this.DOMState.btnEntryLogin.setAttribute('class', 'btn_page_login');\r\n        value = document.createTextNode('Вход');\r\n        this.DOMState.btnEntryLogin.appendChild(value);\r\n        this.DOMState.wrapAuthorization.appendChild(this.DOMState.btnEntryLogin);\r\n\r\n        this.DOMState.btnRegistration = document.createElement('button');\r\n        this.DOMState.btnRegistration.setAttribute('class', 'btn_page_registration');\r\n        value = document.createTextNode('Регистрация');\r\n        this.DOMState.btnRegistration.appendChild(value);\r\n        this.DOMState.wrapAuthorization.appendChild(this.DOMState.btnRegistration);\r\n\r\n        const wrapForm = document.createElement('div');\r\n        wrapForm.setAttribute('class', 'wrap_form');\r\n        this.DOMState.wrapAuthorization.appendChild(wrapForm);\r\n\r\n        this.DOMState.form = document.createElement('form');\r\n        this.DOMState.form.setAttribute('class', 'form');\r\n        wrapForm.appendChild(this.DOMState.form);\r\n\r\n        const wrapName = document.createElement('div');\r\n        wrapName.setAttribute('class', 'wrap_elements wrap_input_name');\r\n\r\n        const labelName = document.createElement('label');\r\n        labelName.setAttribute('for', 'name');\r\n        value = document.createTextNode('Имя:');\r\n        labelName.appendChild(value);\r\n        wrapName.appendChild(labelName);\r\n\r\n        this.DOMState.inputName = document.createElement('input');\r\n        this.DOMState.inputName.setAttribute('id', 'name');\r\n        this.DOMState.inputName.setAttribute('type', 'text');\r\n        this.DOMState.inputName.setAttribute('name', 'name');\r\n        this.DOMState.inputName.setAttribute('placeholder', 'Введите имя');\r\n        wrapName.appendChild(this.DOMState.inputName);\r\n\r\n        this.DOMState.form.appendChild(wrapName);\r\n\r\n        const wrapEmail = document.createElement('div');\r\n        wrapEmail.setAttribute('class', 'wrap_elements wrap_input_email');\r\n\r\n        const labelEmail = document.createElement('label');\r\n        labelEmail.setAttribute('for', 'email');\r\n        value = document.createTextNode('Email:');\r\n        labelEmail.appendChild(value);\r\n        wrapEmail.appendChild(labelEmail);\r\n\r\n        this.DOMState.inputEmail = document.createElement('input');\r\n        this.DOMState.inputEmail.setAttribute('id', 'email');\r\n        this.DOMState.inputEmail.setAttribute('type', 'email');\r\n        this.DOMState.inputEmail.setAttribute('name', 'email');\r\n        this.DOMState.inputEmail.setAttribute('placeholder', 'Введите email');\r\n        wrapEmail.appendChild(this.DOMState.inputEmail);\r\n\r\n        this.DOMState.form.appendChild(wrapEmail);\r\n\r\n        const wrapBtn = document.createElement('div');\r\n        wrapBtn.setAttribute('class', 'wrap_elements wrap_submit');\r\n\r\n        this.DOMState.btnSubmit = document.createElement('button');\r\n        this.DOMState.btnSubmit.setAttribute('class', 'btn btn_submit');\r\n        value = document.createTextNode('Отправить');\r\n        this.DOMState.btnSubmit.appendChild(value);\r\n        wrapBtn.appendChild(this.DOMState.btnSubmit);\r\n\r\n        this.DOMState.form.appendChild(wrapBtn);\r\n\r\n        this.parent.appendChild(this.DOMState.wrapAuthorization);\r\n    }\r\n\r\n    createHeader = () => { \r\n        this.DOMState.header = document.createElement('div');\r\n        this.DOMState.header.setAttribute('class', 'header');\r\n\r\n        const h1 = document.createElement('h1');\r\n\r\n        const p = document.createElement('p');\r\n\r\n        this.DOMState.header.appendChild(h1);\r\n        this.DOMState.header.appendChild(p);\r\n\r\n        this.parent.appendChild(this.DOMState.header);\r\n    }\r\n\r\n    createWindowWelcome = () => {\r\n        let value = '';\r\n\r\n        this.DOMState.windowWelcome = document.createElement('div');\r\n        this.DOMState.windowWelcome.setAttribute('class', 'window_welcome');\r\n\r\n        const h2 = document.createElement('h2');\r\n        value = document.createTextNode('Добро пожаловать в игру \"Морской бой\"!!!');\r\n        h2.appendChild(value);\r\n\r\n        const p = document.createElement('p');\r\n        value = document.createTextNode('click');\r\n        p.appendChild(value);\r\n\r\n        this.DOMState.windowWelcome.appendChild(h2);\r\n        this.DOMState.windowWelcome.appendChild(p);\r\n\r\n        this.parent.appendChild(this.DOMState.windowWelcome);\r\n    }\r\n\r\n    createMainMenu = () => {\r\n        let value = '';\r\n\r\n        this.DOMState.mainMenu = document.createElement('div');\r\n        this.DOMState.mainMenu.setAttribute('class', 'main_menu');\r\n\r\n        this.DOMState.btnEntry = document.createElement('button');\r\n        this.DOMState.btnEntry.setAttribute('class', 'btn btn_entry');\r\n        value = document.createTextNode('Войти');\r\n        this.DOMState.btnEntry.appendChild(value);\r\n        this.DOMState.mainMenu.appendChild(this.DOMState.btnEntry);\r\n\r\n        this.DOMState.btnPlay = document.createElement('button');\r\n        this.DOMState.btnPlay.setAttribute('class', 'btn btn_play');\r\n        value = document.createTextNode('Играть');\r\n        this.DOMState.btnPlay.appendChild(value);\r\n        this.DOMState.mainMenu.appendChild(this.DOMState.btnPlay);\r\n\r\n        this.DOMState.btnContinue = document.createElement('button');\r\n        this.DOMState.btnContinue.setAttribute('class', 'btn btn_continue');\r\n        value = document.createTextNode('Продолжить');\r\n        this.DOMState.btnContinue.appendChild(value);\r\n        this.DOMState.mainMenu.appendChild(this.DOMState.btnContinue);\r\n\r\n        this.DOMState.btnExit = document.createElement('button');\r\n        this.DOMState.btnExit.setAttribute('class', 'btn btn_exit');\r\n        value = document.createTextNode('Выйти');\r\n        this.DOMState.btnExit.appendChild(value);\r\n        this.DOMState.mainMenu.appendChild(this.DOMState.btnExit);\r\n\r\n        this.parent.appendChild(this.DOMState.mainMenu);\r\n    }\r\n\r\n    createBattleground = () => {\r\n        let value = '';\r\n\r\n        this.DOMState.fieldHuman = document.createElement('div');\r\n        this.DOMState.fieldHuman.setAttribute('class', 'wrap_field field_human');\r\n\r\n        this.DOMState.fieldShipsHuman = document.createElement('div');\r\n        this.DOMState.fieldShipsHuman.setAttribute('class', 'field field_ships_human');\r\n        this.DOMState.fieldHuman.appendChild(this.DOMState.fieldShipsHuman);\r\n        this.parent.appendChild(this.DOMState.fieldHuman);\r\n\r\n        //\r\n        this.DOMState.menu = document.createElement('div');\r\n        this.DOMState.menu.setAttribute('class', 'menu');\r\n\r\n        this.DOMState.btnMain = document.createElement('button');\r\n        this.DOMState.btnMain.setAttribute('class', 'btn btn_main');\r\n        value = document.createTextNode('Главное меню');\r\n        this.DOMState.btnMain.appendChild(value);\r\n        this.DOMState.menu.appendChild(this.DOMState.btnMain);\r\n\r\n        this.DOMState.btnStartOver = document.createElement('button');\r\n        this.DOMState.btnStartOver.setAttribute('class', 'btn btn_start_over');\r\n        value = document.createTextNode('Начать заного');\r\n        this.DOMState.btnStartOver.appendChild(value);\r\n        this.DOMState.menu.appendChild(this.DOMState.btnStartOver);\r\n\r\n        this.parent.appendChild(this.DOMState.menu);\r\n\r\n        //        \r\n        this.DOMState.fieldComputer = document.createElement('div');\r\n        this.DOMState.fieldComputer.setAttribute('class', 'wrap_field field_computer');\r\n\r\n        this.DOMState.fieldShipsComputer = document.createElement('div');\r\n        this.DOMState.fieldShipsComputer.setAttribute('class', 'field field_ships_computer');\r\n        this.DOMState.fieldComputer.appendChild(this.DOMState.fieldShipsComputer);\r\n        this.parent.appendChild(this.DOMState.fieldComputer);\r\n    }\r\n\r\n    createPlacementInstruction = () => {\r\n        let value = '';\r\n\r\n        this.DOMState.placementInstruction = document.createElement('div');\r\n        this.DOMState.placementInstruction.setAttribute('class', 'placement_instruction');\r\n        //\r\n        this.DOMState.typePlacement = document.createElement('div');\r\n        this.DOMState.typePlacement.setAttribute('class', 'type-placement-box');\r\n        value = document.createTextNode('1.');\r\n        this.DOMState.typePlacement.appendChild(value);\r\n\r\n        this.DOMState.btnRandom = document.createElement('span');\r\n        this.DOMState.btnRandom.setAttribute('class', 'link');\r\n        this.DOMState.btnRandom.dataset.target = 'random';\r\n        value = document.createTextNode('Случайным образом');\r\n        this.DOMState.btnRandom.appendChild(value);\r\n        this.DOMState.typePlacement.appendChild(this.DOMState.btnRandom);\r\n\r\n        const br = document.createElement('br');\r\n        this.DOMState.typePlacement.appendChild(br);\r\n\r\n        value = document.createTextNode('2.');\r\n        this.DOMState.typePlacement.appendChild(value);\r\n\r\n        this.DOMState.btnManually = document.createElement('span');\r\n        this.DOMState.btnManually.setAttribute('class', 'link');\r\n        this.DOMState.btnManually.dataset.target = 'manually';\r\n        value = document.createTextNode('Методом перетаскивания.');\r\n        this.DOMState.btnManually.appendChild(value);\r\n        this.DOMState.typePlacement.appendChild(this.DOMState.btnManually);\r\n        \r\n        //\r\n        this.DOMState.shipsCollection = document.createElement('div');\r\n        this.DOMState.shipsCollection.setAttribute('class', 'ships_collection');\r\n\r\n        const p = document.createElement('p');\r\n        value = document.createTextNode('Перетащите мышкой корабли на игровое поле. Для установки корабля по вертикали, кликните по нему правой кнопкой мышки.');\r\n        p.appendChild(value);\r\n        this.DOMState.shipsCollection.appendChild(p);\r\n\r\n        const ul = document.createElement('ul');\r\n        ul.setAttribute('class', 'initial_ships');\r\n        this.DOMState.shipsCollection.appendChild(ul);\r\n\r\n        const firstLi = document.createElement('li');\r\n\r\n        const fourdeckShip = document.createElement('div');\r\n        fourdeckShip.setAttribute('class', 'ship fourdeck');\r\n        fourdeckShip.setAttribute('id', 'fourdeck1');\r\n\r\n        const tripledeckShip1 = document.createElement('div');\r\n        tripledeckShip1.setAttribute('class', 'ship tripledeck tripledeck1');\r\n        tripledeckShip1.setAttribute('id', 'tripledeck1');\r\n\r\n        const tripledeckShip2 = document.createElement('div');\r\n        tripledeckShip2.setAttribute('class', 'ship tripledeck tripledeck2');\r\n        tripledeckShip2.setAttribute('id', 'tripledeck2');\r\n\r\n        firstLi.appendChild(fourdeckShip);\r\n        firstLi.appendChild(tripledeckShip1);\r\n        firstLi.appendChild(tripledeckShip2);\r\n\r\n        ul.appendChild(firstLi)\r\n\r\n        const secondLi = document.createElement('li');\r\n\r\n        const doubledeck1 = document.createElement('div');\r\n        doubledeck1.setAttribute('class', 'ship doubledeck doubledeck1');\r\n        doubledeck1.setAttribute('id', 'doubledeck1');\r\n\r\n        const doubledeck2 = document.createElement('div');\r\n        doubledeck2.setAttribute('class', 'ship doubledeck doubledeck2');\r\n        doubledeck2.setAttribute('id', 'doubledeck2');\r\n\r\n        const doubledeck3 = document.createElement('div');\r\n        doubledeck3.setAttribute('class', 'ship doubledeck doubledeck3');\r\n        doubledeck3.setAttribute('id', 'doubledeck3');\r\n\r\n        secondLi.appendChild(doubledeck1);\r\n        secondLi.appendChild(doubledeck2);\r\n        secondLi.appendChild(doubledeck3);\r\n\r\n\r\n        ul.appendChild(secondLi)\r\n\r\n        const thirdLi = document.createElement('li');\r\n\r\n        const singledeck1 = document.createElement('div');\r\n        singledeck1.setAttribute('class', 'ship singledeck singledeck1');\r\n        singledeck1.setAttribute('id', 'singledeck1');\r\n\r\n        const singledeck2 = document.createElement('div');\r\n        singledeck2.setAttribute('class', 'ship singledeck singledeck2');\r\n        singledeck2.setAttribute('id', 'singledeck2');\r\n\r\n        const singledeck3 = document.createElement('div');\r\n        singledeck3.setAttribute('class', 'ship singledeck singledeck3');\r\n        singledeck3.setAttribute('id', 'singledeck3');\r\n\r\n        const singledeck4 = document.createElement('div');\r\n        singledeck4.setAttribute('class', 'ship singledeck singledeck4');\r\n        singledeck4.setAttribute('id', 'singledeck4');\r\n\r\n        thirdLi.appendChild(singledeck1);\r\n        thirdLi.appendChild(singledeck2);\r\n        thirdLi.appendChild(singledeck3);\r\n        thirdLi.appendChild(singledeck4);\r\n\r\n        ul.appendChild(thirdLi)\r\n\r\n        this.DOMState.placementInstruction.appendChild(this.DOMState.typePlacement);\r\n        this.DOMState.placementInstruction.appendChild(this.DOMState.shipsCollection);\r\n        this.parent.appendChild(this.DOMState.placementInstruction);\r\n\r\n        this.DOMState.btnStartFight = document.createElement('button');\r\n        this.DOMState.btnStartFight.setAttribute('class', 'btn btn_start_fight');\r\n        value = document.createTextNode('Начать бой');\r\n        this.DOMState.btnStartFight.appendChild(value);\r\n        this.parent.appendChild(this.DOMState.btnStartFight);\r\n    }\r\n}\n\n//# sourceURL=webpack://project/./src/js/dom.js?");

/***/ }),

/***/ "./src/js/field.js":
/*!*************************!*\
  !*** ./src/js/field.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Field\": () => (/* binding */ Field)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/js/utils.js\");\n/* harmony import */ var _ships__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ships */ \"./src/js/ships.js\");\n\r\n\r\n\r\n\r\n\r\nclass Field {\r\n    // размер стороны игрового поля в px\r\n    static FIELD_SIDE = 0;\r\n    // размер палубы корабля в px\r\n    static SHIP_SIDE = 0;\r\n    // объект с данными кораблей\r\n    // ключём будет являться тип корабля, а значением - массив,\r\n    // первый элемент которого указывает кол-во кораблей данного типа,\r\n    // второй элемент указывает кол-во палуб у корабля данного типа\r\n    static SHIP_DATA = {\r\n        fourdeck: [1, 4],\r\n        tripledeck: [2, 3],\r\n        doubledeck: [3, 2],\r\n        singledeck: [4, 1]\r\n    };\r\n\r\n    constructor(field) {\r\n        // объект игрового поля, полученный в качестве аргумента\r\n        this.field = field;\r\n        // создаём пустой объект, куда будем заносить данные по каждому созданному кораблю\r\n        // эскадры, подробно эти данные рассмотрим при создании объектов кораблей\r\n        this.squadron = {};\r\n        // двумерный массив, в который заносятся координаты кораблей, а в ходе морского\r\n        // боя, координаты попаданий, промахов и заведомо пустых клеток\r\n        this.matrix = [];\r\n        // получаем координаты всех четырёх сторон рамки игрового поля относительно начала\r\n        // document, с учётом возможной прокрутки по вертикали \r\n        let { left, right, top, bottom } = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getCoordinates)(this.field);\r\n        this.fieldLeft = left;\r\n        this.fieldRight = right;\r\n        this.fieldTop = top;\r\n        this.fieldBottom = bottom;\r\n    }\r\n\r\n    static createMatrix() {\r\n        return [...Array(10)].map(() => Array(10).fill(0));\r\n    }\r\n    // n - максимальное значение, которое хотим получить\r\n    static getRandom = n => Math.floor(Math.random() * (n + 1));\r\n\r\n    setStaticConstant () {\r\n        Field.FIELD_SIDE = this.field.offsetWidth;\r\n        Field.SHIP_SIDE = Field.FIELD_SIDE / 10;\r\n    }\r\n\r\n    cleanField() {\r\n        while (this.field.firstChild) {\r\n            this.field.removeChild(this.field.firstChild);\r\n        }\r\n        this.squadron = {};\r\n        this.matrix = Field.createMatrix();\r\n    }\r\n\r\n    randomLocationShips() {\r\n        for (let type in Field.SHIP_DATA) {\r\n            // кол-во кораблей данного типа\r\n            let count = Field.SHIP_DATA[type][0];\r\n            // кол-во палуб у корабля данного типа\r\n            let decks = Field.SHIP_DATA[type][1];\r\n            // прокручиваем кол-во кораблей\r\n            for (let i = 0; i < count; i++) {\r\n                // получаем координаты первой палубы и направление расположения палуб (корабля)\r\n                let options = this.getCoordsDecks(decks);\r\n                // кол-во палуб\r\n                options.decks = decks;\r\n                // имя корабля, понадобится в дальнейшем для его идентификации\r\n                options.shipname = type + String(i + 1);\r\n                // создаём экземпляр корабля со свойствами, указанными в\r\n                // объекте options с помощью класса Ship\r\n                const ship = new _ships__WEBPACK_IMPORTED_MODULE_1__.Ships(this, options);\r\n                ship.createShip();\r\n            }\r\n        }\r\n    }\r\n\r\n    getCoordsDecks(decks) {\r\n        // получаем коэффициенты определяющие направление расположения корабля\r\n        // kx == 0 и ky == 1 — корабль расположен горизонтально,\r\n        // kx == 1 и ky == 0 - вертикально.\r\n        let kx = Field.getRandom(1), ky = (kx == 0) ? 1 : 0,\r\n            x, y;\r\n\r\n        // в зависимости от направления расположения, генерируем\r\n        // начальные координаты\r\n        if (kx == 0) {\r\n            x = Field.getRandom(9); y = Field.getRandom(10 - decks);\r\n        } else {\r\n            x = Field.getRandom(10 - decks); y = Field.getRandom(9);\r\n        }\r\n\r\n        const obj = {x, y, kx, ky}\r\n        // проверяем валидность координат всех палуб корабля\r\n        const result = this.checkLocationShip(obj, decks);\r\n        // если координаты невалидны, снова запускаем функцию\r\n        if (!result) return this.getCoordsDecks(decks);\r\n        return obj;\r\n    }\r\n\r\n    checkLocationShip(obj, decks) {\r\n        let { x, y, kx, ky, fromX, toX, fromY, toY } = obj;\r\n\r\n        // формируем индексы, ограничивающие двумерный массив по оси X (строки)\r\n        // если координата 'x' равна нулю, то это значит, что палуба расположена в самой\r\n        // верхней строке, т. е. примыкает к верхней границе и началом цикла будет строка\r\n        // с индексом 0, в противном случае, нужно начать проверку со строки с индексом\r\n        // на единицу меньшим, чем у исходной, т.е. находящейся выше исходной строки\r\n        fromX = (x == 0) ? x : x - 1;\r\n        // если условие истинно - это значит, что корабль расположен вертикально и его\r\n        // последняя палуба примыкает к нижней границе игрового поля\r\n        // поэтому координата 'x' последней палубы будет индексом конца цикла\r\n        if (x + kx * decks == 10 && kx == 1) toX = x + kx * decks;\r\n        // корабль расположен вертикально и между ним и нижней границей игрового поля\r\n        // есть, как минимум, ещё одна строка, координата этой строки и будет\r\n        // индексом конца цикла\r\n        else if (x + kx * decks < 10 && kx == 1) toX = x + kx * decks + 1;\r\n        // корабль расположен горизонтально вдоль нижней границы игрового поля\r\n        else if (x == 9 && kx == 0) toX = x + 1;\r\n        // корабль расположен горизонтально где-то по середине игрового поля\r\n        else if (x < 9 && kx == 0) toX = x + 2;\r\n\r\n        // формируем индексы начала и конца выборки по столбцам\r\n        // принцип такой же, как и для строк\r\n        fromY = (y == 0) ? y : y - 1;\r\n        if (y + ky * decks == 10 && ky == 1) toY = y + ky * decks;\r\n        else if (y + ky * decks < 10 && ky == 1) toY = y + ky * decks + 1;\r\n        else if (y == 9 && ky == 0) toY = y + 1;\r\n        else if (y < 9 && ky == 0) toY = y + 2;\r\n\r\n        if (toX === undefined || toY === undefined) return false;\r\n\r\n        // отфильтровываем ячейки, получившегося двумерного массива,\r\n        // содержащие 1, если такие ячейки существуют - возвращаем false\r\n        if (this.matrix.slice(fromX, toX)\r\n            .filter(arr => arr.slice(fromY, toY).includes(1))\r\n            .length > 0) return false;\r\n        return true;\r\n    }\r\n}\n\n//# sourceURL=webpack://project/./src/js/field.js?");

/***/ }),

/***/ "./src/js/placement.js":
/*!*****************************!*\
  !*** ./src/js/placement.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Placement\": () => (/* binding */ Placement)\n/* harmony export */ });\n/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./field */ \"./src/js/field.js\");\n/* harmony import */ var _ships__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ships */ \"./src/js/ships.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/js/utils.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../index */ \"./index.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Placement {\r\n    // объект с координатами стророн игрового поля\r\n    static FRAME_COORDS \r\n    \r\n    constructor(field) {\r\n        this.field = field;\r\n        \r\n        Placement.FRAME_COORDS = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(this.field);\r\n        // объект перетаскивамого корабля\r\n        this.dragObject = {};\r\n        // флаг нажатия на левую кнопку мыши\r\n        this.pressed = false;\r\n    }\r\n\r\n    static getShipName = el => el.getAttribute('id');\r\n\r\n    static getCloneDecks = el => {\r\n        const type = Placement.getShipName(el).slice(0, -1);\r\n        return _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_DATA[type][1];\r\n    }\r\n\r\n    setObserver() {\r\n        if (_index__WEBPACK_IMPORTED_MODULE_3__.stateGame.isHandlerPlacement) return;\r\n\r\n        document.addEventListener('mousedown', this.onMouseDown.bind(this));\r\n        document.addEventListener('mousemove', this.onMouseMove.bind(this));\r\n        document.addEventListener('mouseup', this.onMouseUp.bind(this));\r\n        \r\n        this.field.addEventListener('contextmenu', this.rotationShip.bind(this));\r\n        _index__WEBPACK_IMPORTED_MODULE_3__.stateGame.isHandlerPlacement = true;\r\n    }\r\n\r\n    onMouseDown(e) {\r\n        // если нажата не левая кнопка мыши или игра уже запущена\r\n        if (e.which != 1 || _index__WEBPACK_IMPORTED_MODULE_3__.stateGame.startGame) return;\r\n\r\n        // проверяем, что нажатие произошло над кораблём\r\n        const el = e.target.closest('.ship');\r\n        if(!el) return;\r\n\r\n        this.pressed = true;\r\n\r\n        // переносимый объект и его свойства\r\n        this.dragObject = {\r\n            el,\r\n            parent: el.parentElement,\r\n            next: el.nextElementSibling,\r\n            // координаты, с которых начат перенос\r\n            downX: e.pageX,\r\n            downY: e.pageY,\r\n            // координаты 'left' и 'top' используются при редактировании\r\n            // положения корабля на игровом поле\r\n            left: el.offsetLeft,\r\n            top: el.offsetTop,\r\n            // горизонтальное положение корабля\r\n            kx: 0,\r\n            ky: 1\r\n        };\r\n\r\n        // редактируем положение корабля на игровом поле\r\n        // проверяем, что корабль находится на поле игрока\r\n        if (el.parentElement === _index__WEBPACK_IMPORTED_MODULE_3__.stateDOM.getDOMState().fieldShipsHuman) {\r\n            const name = Placement.getShipName(el);\r\n            // запоминаем текущее направление расположения палуб\r\n            this.dragObject.kx = _index__WEBPACK_IMPORTED_MODULE_3__.human.squadron[name].kx;\r\n            this.dragObject.ky = _index__WEBPACK_IMPORTED_MODULE_3__.human.squadron[name].ky;\r\n        }\r\n    }\r\n\r\n    onMouseMove(e) {\r\n        if (!this.pressed || !this.dragObject.el) return;\r\n\r\n        // получаем координаты сторон клона корабля\r\n        let { left, right, top, bottom } = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(this.dragObject.el);\r\n\r\n        // если клона ещё не существует, создаём его\r\n        if (!this.clone) {\r\n            // получаем количество палуб у перемещаемого корабля\r\n            this.decks = Placement.getCloneDecks(this.dragObject.el);\r\n            // создаём клон, используя ранее полученные координаты его сторон\r\n            this.clone = this.creatClone({left, right, top, bottom}) || null;\r\n            // если по каким-то причинам клон создать не удалось, выходим из функции\r\n            if (!this.clone) return;\r\n\r\n            // вычисляем сдвиг курсора по координатам X и Y\r\n            this.shiftX = this.dragObject.downX - left;\r\n            this.shiftY = this.dragObject.downY - top;\r\n            // z-index нужен для позиционирования клона над всеми элементами DOM\r\n            this.clone.style.zIndex = '1000';\r\n            // перемещаем клон в BODY\r\n            document.body.appendChild(this.clone);\r\n\r\n            // удаляем устаревший экземпляр корабля, если он существует\r\n            // используется при редактировании положения корабля\r\n            this.removeShipFromSquadron(this.clone);\r\n        }\r\n\r\n        // координаты клона относительно BODY с учётом сдвига курсора\r\n        // относительно верней левой точки\r\n        let currentLeft = Math.round(e.pageX - this.shiftX),\r\n            currentTop = Math.round(e.pageY - this.shiftY);\r\n        this.clone.style.left = `${currentLeft}px`;\r\n        this.clone.style.top = `${currentTop}px`;\r\n\r\n        // проверяем, что клон находится в пределах игрового поля, с учётом\r\n        // небольших погрешностей (14px)\r\n        if (left >= Placement.FRAME_COORDS.left - 14 && right <= Placement.FRAME_COORDS.right + 14 && top >= Placement.FRAME_COORDS.top - 14 && bottom <= Placement.FRAME_COORDS.bottom + 14) {\r\n            // клон находится в пределах игрового поля,\r\n            // подсвечиваем его контур зелёным цветом\r\n            this.clone.classList.remove('unsuccess');\r\n            this.clone.classList.add('success');\r\n\r\n            const { x, y } = this.getCoordsCloneInMatrix({ left, right, top, bottom });\r\n            const obj = {\r\n                x,\r\n                y,\r\n                kx: this.dragObject.kx,\r\n                ky: this.dragObject.ky\r\n            };\r\n\r\n            const result = _index__WEBPACK_IMPORTED_MODULE_3__.human.checkLocationShip(obj, this.decks);\r\n            if (!result) {\r\n                // в соседних клетках находятся ранее установленные корабли,\r\n                // подсвечиваем его контур красным цветом\r\n                this.clone.classList.remove('success');\r\n                this.clone.classList.add('unsuccess');\r\n            }\r\n        } else {\r\n            // клон находится за пределами игрового поля,\r\n            // подсвечиваем его контур красным цветом\r\n            this.clone.classList.remove('success');\r\n            this.clone.classList.add('unsuccess');\r\n        }\r\n    }\r\n\r\n    onMouseUp(e) {\r\n        this.pressed = false;\r\n        // если клона не существует\r\n        if (!this.clone) return;\r\n\r\n        // если координаты клона невалидны, возвращаем его на место,\r\n        // откуда был начат перенос\r\n        if (this.clone.classList.contains('unsuccess')) {\r\n            this.clone.classList.remove('unsuccess');\r\n            this.clone.rollback();\r\n        } else {\r\n            // создаём экземпляр нового корабля, исходя\r\n            // из окончательных координат клона \r\n            this.createShipAfterMoving();\r\n        }\r\n\r\n        // удаляем объекты 'clone' и 'dragObject'\r\n        this.removeClone();\r\n    }\r\n\r\n    rotationShip(e) {\r\n        // запрещаем появление контекстного меню\r\n        e.preventDefault();\r\n        if (e.which != 3 || _index__WEBPACK_IMPORTED_MODULE_3__.stateGame.startGame) return;\r\n\r\n        const el = e.target.closest('.ship');\r\n        const name = Placement.getShipName(el);\r\n\r\n        // нет смысла вращать однопалубный корабль\r\n        if (_index__WEBPACK_IMPORTED_MODULE_3__.human.squadron[name].decks == 1) return;\r\n\r\n        // объект с текущими коэффициентами и координатами корабля\r\n        const obj = {\r\n            kx: (_index__WEBPACK_IMPORTED_MODULE_3__.human.squadron[name].kx == 0) ? 1 : 0,\r\n            ky: (_index__WEBPACK_IMPORTED_MODULE_3__.human.squadron[name].ky == 0) ? 1 : 0,\r\n            x: _index__WEBPACK_IMPORTED_MODULE_3__.human.squadron[name].x,\r\n            y: _index__WEBPACK_IMPORTED_MODULE_3__.human.squadron[name].y\r\n        };\r\n        // очищаем данные о редактируемом корабле\r\n        const decks = _index__WEBPACK_IMPORTED_MODULE_3__.human.squadron[name].arrDecks.length;\r\n        this.removeShipFromSquadron(el);\r\n        _index__WEBPACK_IMPORTED_MODULE_3__.human.field.removeChild(el);\r\n\r\n        // проверяем валидность координат после поворота\r\n        // если координаты не валидны, возвращаем старые коэффициенты\r\n        // направления положения корабля\r\n        const result = _index__WEBPACK_IMPORTED_MODULE_3__.human.checkLocationShip(obj, decks);\r\n        if(!result) {\r\n            obj.kx = (obj.kx == 0) ? 1 : 0;\r\n            obj.ky = (obj.ky == 0) ? 1 : 0;\r\n        }\r\n\r\n        // добавляем в объект свойства нового корабля\r\n        obj.shipname = name;\r\n        obj.decks = decks;\r\n\r\n        // создаём экземпляр нового корабля\r\n        const ship = new _ships__WEBPACK_IMPORTED_MODULE_1__.Ships(_index__WEBPACK_IMPORTED_MODULE_3__.human, obj);\r\n        ship.createShip();\r\n\r\n        // кратковременно подсвечиваем рамку корабля красным цветом\r\n        if (!result) {\r\n            const el = document.getElementById(`${name}`);\r\n            el.classList.add('unsuccess');\r\n            setTimeout(() => { el.classList.remove('unsuccess') }, 750);\r\n        }\r\n    }\r\n\r\n    creatClone() {\r\n        const clone = this.dragObject.el;\r\n        const oldPosition = this.dragObject;\r\n\r\n        clone.rollback = () => {\r\n            // редактиование положения корабля\r\n            // получаем родительский элемент и\r\n            // возвращаем корабль на исходное место на игровом поле\r\n            if (oldPosition.parent == _index__WEBPACK_IMPORTED_MODULE_3__.stateDOM.getDOMState().fieldShipsHuman) {\r\n                clone.style.left = `${oldPosition.left}px`;\r\n                clone.style.top = `${oldPosition.top}px`;\r\n                clone.style.zIndex = '';\r\n                oldPosition.parent.insertBefore(clone, oldPosition.next);\r\n                this.createShipAfterMoving();\r\n            } else {\r\n                // возвращаем корабль в контейнер 'shipsCollection'\r\n                clone.removeAttribute('style');\r\n                oldPosition.parent.insertBefore(clone, oldPosition.next);\r\n            }\r\n        };\r\n        return clone;\r\n    }\r\n\r\n    removeClone() {\r\n        delete this.clone;\r\n        this.dragObject = {};\r\n    }\r\n\r\n    createShipAfterMoving() {\r\n        // получаем координаты, пересчитанные относительно игрового поля\r\n        const coords = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getCoordinates)(this.clone);\r\n        let { left, top, x, y } = this.getCoordsCloneInMatrix(coords);\r\n        this.clone.style.left = `${left}px`;\r\n        this.clone.style.top = `${top}px`;\r\n        // переносим клон внутрь игрового поля\r\n        _index__WEBPACK_IMPORTED_MODULE_3__.stateDOM.getDOMState().fieldShipsHuman.appendChild(this.clone);\r\n        this.clone.classList.remove('success');\r\n\r\n        // создаём объект со свойствами нового корабля\r\n        const options = {\r\n            shipname: Placement.getShipName(this.clone),\r\n            x,\r\n            y,\r\n            kx: this.dragObject.kx,\r\n            ky: this.dragObject.ky,\r\n            decks: this.decks\r\n        };\r\n\r\n        // создаём экземпляр нового корабля\r\n        const ship = new _ships__WEBPACK_IMPORTED_MODULE_1__.Ships(_index__WEBPACK_IMPORTED_MODULE_3__.human, options);\r\n        ship.createShip();\r\n        // теперь в игровом поле находится сам корабль, поэтому его клон удаляем из DOM\r\n        _index__WEBPACK_IMPORTED_MODULE_3__.stateDOM.getDOMState().fieldShipsHuman.removeChild(this.clone);\r\n    }\r\n\r\n    getCoordsCloneInMatrix({left, right, top, bottom} = coords) {\r\n        // вычисляем разницу координат соотвествующих сторон\r\n        // клона и игрового поля\r\n        let computedLeft = left - Placement.FRAME_COORDS.left,\r\n            computedRight = right - Placement.FRAME_COORDS.left,\r\n            computedTop = top - Placement.FRAME_COORDS.top,\r\n            computedBottom = bottom - Placement.FRAME_COORDS.top;\r\n\r\n        // создаём объект, куда поместим итоговые значения\r\n        const obj = {};\r\n\r\n        // в результате выполнения условия, убираем неточности позиционирования клона\r\n        let ft = (computedTop < 0) ? 0 : (computedBottom > _field__WEBPACK_IMPORTED_MODULE_0__.Field.FIELD_SIDE) ? _field__WEBPACK_IMPORTED_MODULE_0__.Field.FIELD_SIDE - _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE : computedTop;\r\n        let fl = (computedLeft < 0) ? 0 : (computedRight > _field__WEBPACK_IMPORTED_MODULE_0__.Field.FIELD_SIDE) ? _field__WEBPACK_IMPORTED_MODULE_0__.Field.FIELD_SIDE - _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE * this.decks : computedLeft;\r\n\r\n        obj.top = Math.round(ft / _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE) * _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE;\r\n        obj.left = Math.round(fl / _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE) * _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE;\r\n        // переводим значение в координатах матрицы\r\n        obj.x = obj.top / _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE;\r\n        obj.y = obj.left / _field__WEBPACK_IMPORTED_MODULE_0__.Field.SHIP_SIDE;\r\n\r\n        return obj;\r\n    }\r\n\r\n    removeShipFromSquadron(el) {\r\n        // имя редактируемого корабля\r\n        const name = Placement.getShipName(el);\r\n        // если корабля с таким именем не существует,\r\n        // прекращаем работу функции\r\n        if (!_index__WEBPACK_IMPORTED_MODULE_3__.human.squadron[name]) return;\r\n\r\n        // получаем массив с координатами палуб корабля и\r\n        // записываем в него нули, что означает - пустое место\r\n        const arr = _index__WEBPACK_IMPORTED_MODULE_3__.human.squadron[name].arrDecks;\r\n        for (let coords of arr) {\r\n            const [x, y] = coords;\r\n            _index__WEBPACK_IMPORTED_MODULE_3__.human.matrix[x][y] = 0;\r\n        }\r\n        // удаляем всю информацию о корабле из массива эскадры\r\n        delete _index__WEBPACK_IMPORTED_MODULE_3__.human.squadron[name];\r\n    }\r\n}\n\n//# sourceURL=webpack://project/./src/js/placement.js?");

/***/ }),

/***/ "./src/js/routing.js":
/*!***************************!*\
  !*** ./src/js/routing.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Routing\": () => (/* binding */ Routing)\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index */ \"./index.js\");\n\r\n\r\n\r\nclass Routing {\r\n    constructor ({btnEntry,btnPlay,btnInstruction,btnExit,btnMain,btnStartOver,btnRandom,btnManually,btnStartFight,btnContinue}) {\r\n        this.btnEntry = btnEntry;\r\n        this.btnPlay = btnPlay;\r\n        this.btnInstruction = btnInstruction;\r\n        this.btnExit = btnExit;\r\n        this.btnMain = btnMain;\r\n        this.btnStartOver = btnStartOver;\r\n        this.btnRandom = btnRandom;\r\n        this.btnManually = btnManually;\r\n        this.btnStartFight = btnStartFight;\r\n        this.btnContinue = btnContinue;\r\n        this.SPAState = {};\r\n    }\r\n\r\n    setObserver () {\r\n        window.addEventListener('hashchange', this.switchToStateFromURLHash);\r\n        this.btnPlay.addEventListener('click', this.switchToGamePage);\r\n        this.btnMain.addEventListener('click', this.switchToMainPage);\r\n        this.btnRandom.addEventListener('click', this.switchToGamePageRandom);\r\n        this.btnManually.addEventListener('click', this.switchToGamePageManually);\r\n        this.btnStartFight.addEventListener('click', this.switchToGamePageFight);\r\n        this.btnContinue.addEventListener('click', this.switchToGamePageFight);\r\n        this.btnStartOver.addEventListener('click', this.switchToGamePage);\r\n        this.btnEntry.addEventListener('click', this.switchToLoginPage);\r\n        this.btnExit.addEventListener('click', () => {\r\n            _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.isLogin = false;\r\n            // очищаем поле игрока\r\n            _index__WEBPACK_IMPORTED_MODULE_0__.human.cleanField();\r\n            _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().header.querySelector('p').innerHTML = '';\r\n\r\n            // устанавливаем флаги в исходное состояние\r\n            _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.startGame = false;\r\n            _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.compShot = false;\r\n\r\n           if (_index__WEBPACK_IMPORTED_MODULE_0__.stateGame.control) {\r\n                // обнуляем массивы с координатами выстрела\r\n            _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.control.coordsRandomHit = [];\r\n            _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.control.coordsFixedHit = [];\r\n            _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.control.coordsAroundHit = [];\r\n            // сбрасываем значения объекта tempShip\r\n            _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.control.resetTempShip();\r\n           }\r\n\r\n            this.switchToStateFromURLHash();\r\n        });\r\n    }\r\n\r\n    switchToStateFromURLHash = () => {\r\n        const URLHash = window.location.hash;\r\n        \r\n        // убираем из закладки УРЛа решётку\r\n        const stateStr = URLHash.substr(1);\r\n        \r\n        if ( stateStr!=\"\" ) { // если закладка непустая, читаем из неё состояние и отображаем\r\n            this.SPAState = { pagename: stateStr };\r\n        } else {\r\n            this.SPAState = {pagename:'Main'}; // иначе показываем главную страницу\r\n            this.switchToState(this.SPAState.pagename)\r\n        }\r\n        // обновляем вариабельную часть страницы под текущее состояние\r\n        switch ( this.SPAState.pagename ) {\r\n            case 'Main':\r\n                if (_index__WEBPACK_IMPORTED_MODULE_0__.stateGame.isWelcome) {\r\n                    _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().mainMenu.classList.remove('hide');\r\n                    _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().menu.classList.add('hide');\r\n                    _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().placementInstruction.classList.add('hide');\r\n                    _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().wrapAuthorization.classList.add('hide');\r\n\r\n                    this.btnStartFight.classList.add('hide');\r\n                    this.btnExit.classList.add('hide');\r\n                    this.btnEntry.classList.add('hide');\r\n\r\n                    document.querySelectorAll('.wrap_field').forEach(elem=>elem.classList.add('hide'));\r\n\r\n                    if(_index__WEBPACK_IMPORTED_MODULE_0__.stateGame.startGame) {\r\n                        this.btnContinue.classList.remove('hide');\r\n                        this.btnPlay.classList.add('hide');\r\n                    } else {\r\n                        this.btnContinue.classList.add('hide');\r\n                        this.btnPlay.classList.remove('hide');\r\n                    }\r\n\r\n                    if (_index__WEBPACK_IMPORTED_MODULE_0__.stateGame.isLogin) {\r\n                        this.btnExit.classList.remove('hide');\r\n                        this.btnEntry.classList.add('hide');\r\n                    } else {\r\n                        this.btnExit.classList.add('hide');\r\n                        this.btnEntry.classList.remove('hide');\r\n                        this.btnPlay.classList.add('hide');\r\n                        this.btnContinue.classList.add('hide');\r\n                    }\r\n\r\n                    _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.title.innerHTML = 'Морской бой';\r\n                } else {\r\n                    _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().mainMenu.classList.add('hide');\r\n                    _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().menu.classList.add('hide');\r\n                    _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().placementInstruction.classList.add('hide');\r\n                    _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().wrapAuthorization.classList.add('hide');\r\n\r\n                    this.btnStartFight.classList.add('hide');\r\n\r\n                    document.querySelector('.icon_sound').classList.add('hide');\r\n                    document.querySelectorAll('.wrap_field').forEach(elem=>elem.classList.add('hide'));\r\n                }\r\n                break;\r\n\r\n            case 'Game':\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().mainMenu.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().menu.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().shipsCollection.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().placementInstruction.classList.remove('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().fieldComputer.hidden = true;\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().wrapAuthorization.classList.add('hide');\r\n\r\n                this.btnStartOver.classList.add('hide');\r\n                this.btnStartFight.classList.add('hide');\r\n\r\n                document.querySelectorAll('.wrap_field').forEach(elem=>elem.classList.remove('hide'));\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.title.innerHTML = 'Расстановка кораблей';\r\n                break;\r\n\r\n            case 'Game_manually':\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().shipsCollection.classList.remove('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().mainMenu.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().menu.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().fieldComputer.hidden = true;\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().wrapAuthorization.classList.add('hide');\r\n\r\n                this.btnStartOver.classList.add('hide');\r\n                this.btnStartFight.classList.add('hide');\r\n\r\n                document.querySelectorAll('.wrap_field').forEach(elem=>elem.classList.remove('hide'));\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.title.innerHTML = 'Расстановка кораблей';\r\n                break;\r\n\r\n            case 'Game_random':\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().mainMenu.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().menu.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().shipsCollection.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().placementInstruction.classList.remove('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().fieldComputer.hidden = true;\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().wrapAuthorization.classList.add('hide');\r\n\r\n                this.btnStartOver.classList.add('hide');\r\n                this.btnStartFight.classList.remove('hide');\r\n\r\n                document.querySelectorAll('.wrap_field').forEach(elem=>elem.classList.remove('hide'));\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.title.innerHTML = 'Расстановка кораблей';\r\n                break;\r\n\r\n            case 'Game_fight':\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().mainMenu.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().menu.classList.remove('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().placementInstruction.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().fieldComputer.hidden = false;\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().wrapAuthorization.classList.add('hide');\r\n\r\n                this.btnStartFight.classList.add('hide');\r\n                this.btnStartOver.classList.add('hide');\r\n\r\n                document.querySelectorAll('.wrap_field').forEach(elem=>elem.classList.remove('hide'));\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.title.innerHTML = 'Морской бой между эскадрами';                \r\n                break;\r\n            case 'Login':\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().mainMenu.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().menu.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().placementInstruction.classList.add('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().fieldComputer.hidden = true;\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().wrapAuthorization.classList.remove('hide');\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().btnEntryLogin.classList.add('active');\r\n\r\n                this.btnStartFight.classList.add('hide');\r\n                this.btnStartOver.classList.add('hide');\r\n\r\n                document.querySelector('.wrap_input_name').classList.add('hide');\r\n                document.querySelectorAll('.wrap_field').forEach(elem=>elem.classList.add('hide'));\r\n\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateGame.title.innerHTML = 'Введите email для входа.';\r\n                _index__WEBPACK_IMPORTED_MODULE_0__.stateDOM.getDOMState().btnSubmit.innerHTML = 'Войти';               \r\n                break;\r\n        }        \r\n    }\r\n\r\n    switchToState = (newState) => {\r\n        // устанавливаем закладку УРЛа\r\n        let stateStr = '';\r\n        if (typeof newState === 'string') {\r\n            stateStr = newState;\r\n        } else {\r\n            stateStr = newState.pagename;\r\n        }        \r\n        \r\n        location.hash = stateStr;\r\n    }\r\n\r\n    switchToMainPage = () => {\r\n        this.switchToState( { pagename:'Main' } );\r\n    }\r\n      \r\n    switchToGamePage = () => {\r\n        this.switchToState( { pagename:'Game' } );\r\n    }\r\n\r\n    switchToGamePageManually = () => {\r\n        this.switchToState( { pagename:'Game_manually' } );\r\n    }\r\n\r\n    switchToGamePageRandom = () => {\r\n        this.switchToState( { pagename:'Game_random' } );\r\n    }\r\n\r\n    switchToGamePageFight = () => {\r\n        this.switchToState( { pagename:'Game_fight' } );\r\n    }\r\n\r\n    switchToLoginPage = () => {\r\n        this.switchToState( { pagename:'Login' } );\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://project/./src/js/routing.js?");

/***/ }),

/***/ "./src/js/ships.js":
/*!*************************!*\
  !*** ./src/js/ships.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ships\": () => (/* binding */ Ships)\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index */ \"./index.js\");\n/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./field */ \"./src/js/field.js\");\n\r\n\r\n\r\n\r\n\r\nclass Ships {\r\n    constructor(self, { x, y, kx, ky, decks, shipname }) {\r\n        // с каким экземпляром работаем\r\n        this.player = (self === _index__WEBPACK_IMPORTED_MODULE_0__.human) ? _index__WEBPACK_IMPORTED_MODULE_0__.human : _index__WEBPACK_IMPORTED_MODULE_0__.computer;\r\n        // this.player = self;\r\n        // на каком поле создаётся данный корабль\r\n        this.field = self.field;\r\n        // уникальное имя корабля\r\n        this.shipname = shipname;\r\n        //количество палуб\r\n        this.decks = decks;\r\n        // координата X первой палубы\r\n        this.x = x;\r\n         // координата Y первой палубы\r\n        this.y = y;\r\n        // направлении расположения палуб\r\n        this.kx = kx;\r\n        this.ky = ky;\r\n        // счётчик попаданий\r\n        this.hits = 0;\r\n        // массив с координатами палуб корабля, является элементом squadron\r\n        this.arrDecks = [];\r\n    }\r\n\r\n    static showShip(self, shipname, x, y, kx) {\r\n        // создаём новый элемент с указанным тегом\r\n        const div = document.createElement('div');\r\n        // из имени корабля убираем цифры и получаем имя класса\r\n        const classname = shipname.slice(0, -1);\r\n        // получаем имя класса в зависимости от направления расположения корабля\r\n        let dir;\r\n        if(classname !== 'singledeck'){\r\n            dir = (kx == 1) ? ' vertical' : '';\r\n        } else (\r\n            dir = ''\r\n        )\r\n        \r\n\r\n        // устанавливаем уникальный идентификатор для корабля\r\n        div.setAttribute('id', shipname);\r\n        // собираем в одну строку все классы \r\n        div.className = `ship ${classname}${dir}`;\r\n        // через атрибут 'style' задаём позиционирование кораблю относительно\r\n        // его родительского элемента\r\n        // смещение вычисляется путём умножения координаты первой палубы на\r\n        // размер клетки игрового поля, этот размер совпадает с размером палубы\r\n        div.style.cssText = `left:${y * _field__WEBPACK_IMPORTED_MODULE_1__.Field.SHIP_SIDE}px; top:${x * _field__WEBPACK_IMPORTED_MODULE_1__.Field.SHIP_SIDE}px;`;\r\n        self.field.appendChild(div);\r\n        if (dir === ' vertical') {\r\n            div.style.transform = 'rotate(90deg)';\r\n            div.style.transformOrigin = `${_field__WEBPACK_IMPORTED_MODULE_1__.Field.SHIP_SIDE / 2}px ${_field__WEBPACK_IMPORTED_MODULE_1__.Field.SHIP_SIDE / 2}px`;\r\n        }\r\n    }\r\n\r\n    createShip() {\r\n        let { player, field, shipname, decks, x, y, kx, ky, hits, arrDecks, k = 0 } = this;\r\n\r\n        while (k < decks) {\r\n            // записываем координаты корабля в двумерный массив игрового поля\r\n            // теперь наглядно должно быть видно, зачем мы создавали два\r\n            // коэффициента направления палуб\r\n            // если коэффициент равен 1, то соответствующая координата будет\r\n            // увеличиваться при каждой итерации\r\n            // если равен нулю, то координата будет оставаться неизменной\r\n            // таким способом мы очень сократили и унифицировали код\r\n            let i = x + k * kx, j = y + k * ky;\r\n\r\n            // значение 1, записанное в ячейку двумерного массива, говорит о том, что\r\n            // по данным координатам находится палуба некого корабля\r\n            player.matrix[i][j] = 1;\r\n            // записываем координаты палубы\r\n            arrDecks.push([i, j]);\r\n            k++;\r\n        }\r\n\r\n        // заносим информацию о созданном корабле в объект эскадры\r\n        player.squadron[shipname] = {arrDecks, hits, x, y, kx, ky};\r\n        // если корабль создан для игрока, выводим его на экран\r\n        if (player === _index__WEBPACK_IMPORTED_MODULE_0__.human) {\r\n            Ships.showShip(_index__WEBPACK_IMPORTED_MODULE_0__.human, shipname, x, y, kx);\r\n            // когда количество кораблей в эскадре достигнет 10, т.е. все корабли\r\n            // сгенерированны, то можно показать кнопку запуска игры\r\n            if (Object.keys(player.squadron).length == 10) {\r\n                // buttonPlay.hidden = false;\r\n                document.querySelector('.btn_start_fight').classList.remove('hide');\r\n            }\r\n        }\r\n    }\r\n}\n\n//# sourceURL=webpack://project/./src/js/ships.js?");

/***/ }),

/***/ "./src/js/utils.js":
/*!*************************!*\
  !*** ./src/js/utils.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getCoordinates\": () => (/* binding */ getCoordinates)\n/* harmony export */ });\n\r\n\r\nconst getCoordinates = el => {\r\n\tconst coords = el.getBoundingClientRect();\r\n\treturn {\r\n\t\tleft: coords.left + window.pageXOffset,\r\n\t\tright: coords.right + window.pageXOffset,\r\n\t\ttop: coords.top + window.pageYOffset,\r\n\t\tbottom: coords.bottom + window.pageYOffset\r\n\t};\r\n};\n\n//# sourceURL=webpack://project/./src/js/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;